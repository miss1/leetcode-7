## 数组

常见操作
* 随机访问 -> O(1)
* 根据索引修改 -> O(1)
* 遍历数组 -> O(n)
* 插入数值到数组 -> O(n)
* 从数组删除数值 -> O(n)
* 从数组最后插入/删除 -> O(1)
* js sort排序 -> O(nlogn)

题目：414，88，380，41，59，859

## 栈
后进先出

常见操作
* 进栈 - push -> O(1)
* 出栈 - pop -> O(1)
* 取栈顶 - top -> O(1)
* 判断是否为空栈 - isEmpty -> O(1)

应用
* 深度优先遍历的基础
* 函数调用栈
* 浏览器前进后退
* 匹配括号
* 单调栈寻找下一个更大（小）元素

小知识 -> 波兰表示法(前缀)和逆波兰表示法(后缀)
* 逻辑、算术和代数表示方法
* 操作符的位置（+ 3 4）-> （3 4 +）-> (3 + 4)
* 逆波兰表达式可用栈计算（遇到数字就将数字压栈，遇到操作符，就将栈顶的两个元素取出计算，将计算结果再压入栈）(题目150)

题目：946，150，1381，394，224，227

## 队列
先进先出
 
常见操作
* 插入 - 在队列尾部添加元素
* 删除 - 在队列头部删除元素
* 查看首个元素 - 返回队列头部的元素值

时间复杂度（数组实现）
* 插入 -> O(1) 
* 删除 -> O(n) -> 要实现O(1)可以用两个指针head和tail，需要动态开辟内存
* 查看首个元素 -> O(1)
 
时间复杂度（链表实现）
* 插入 -> O(n) -> 要实现O(1)只要维护一个尾节点引用tail
* 删除 -> O(1)
* 查看首个元素 -> O(1)

应用
* 广度优先遍历（BFS）
* HTTP请求队列

## 专题

### 滑动窗口
主要用来处理连续问题，比如求解：*连续子数组XXX*，*连续子串XXX*

固定窗口大小
* 初始化左指针l为0
* 初始化右指针r，使得 r-l+1 等于窗口（数组）大小
* 同时移动l 和 r，判断窗口内连续元素是否满足题目条件
* 若满足，判断是否需要更新最优解，不满足则继续

可变窗口大小
* l和r都初始化为0
* r指针移动一步
* 判断窗口内连续元素是否满足题目条件
* 若满足，判断是否需要更新最优解，并尝试通过移动l指针缩小窗口大小，循环执行此步骤
* 不满足则继续
* 总结：r指针不断向右移动，l指针只在满足条件后才移动

代码模板
```
初始化慢指针 = 0
初始化 ans

for 快指针 in 可迭代集合
   更新窗口内信息
   while 信息满足题目条件
      更新答案
      扩展或者收缩窗口
      慢指针移动
返回 ans
```

题目：3，76，209，438，904，930，992，978，1004，1234，1248，1658

### 前缀和
理解
* 数列nums的前n项和
* pre[i] = pre[i-1] + nums[i]

跟滑动窗口类似，适合在题目要求连续的情况下使用

使用场景
* 差分（1109）
* 前缀和与二分。如果nums是一个正整数数组，那么其前缀和一定单调递增
* 求区间内的 1 的个数。如求任意区间内的1的个数，可以将1以外的数字预处理为0，然后做前缀和，最后做差求区间和（1871）
* 区间值计数。求nums中的值在[lower, upper]之间的数有多少，可以开辟一个与nums值域等大的数组，统计nums值出现的频率，再做前缀和（1862）
* 区间值计数扩展。在上面情况下增加索引限制。可以先做一个二维前缀和pre[i][j]表示前i项j的出现次数（1906）

题目：467，795，904，992，1109

### 单调栈
理解：单调栈是要求栈中的元素是单调递增或者单调递减的（取决于出栈顺序，出栈元素单调增则为单调递增栈）

适合的题目是求解： *下一个大于XXX*，*下一个小于XXX*，*在其之后第一个小（大）于其本身的位置*

过程
* 如果压栈之后仍然可以保持单调性，那么直接压
* 否则先弹出栈的元素，直到压入之后可以保持单调性

原理
* 单调递增栈，被弹出的元素都是小于当前元素
* 因此在其之后小于其本身的最近的就是当前元素
* eg，stack=[5,3,2,1] cur=4

代码模板
```javascript
// 739.获取在其之后第一个大于其本身的位置
// T=[1,7,4,5,2,9] -> result=[1,4,1,2,1,0]
var monostoneStack = function (T) {
  let stack = [];
  let result = [];
  for (let i = 0; i < T.length; i++) {
    result[i] = 0;
    while (stack.length > 0 && T[stack[stack.length - 1]] < T[i]) {
      let peek = stack.pop();
      result[peek] = i - peek;
    }
    stack.push(i);
  }
  return result;
};
```

题目：42，84，739，255，768；316，321，402，1081

单调队列：239

### 栈匹配
使用场景
* 判断有效括号(())
* 链表的回文判断

题目： 20，678，2116

