## 数组

常见操作
* 随机访问 -> O(1)
* 根据索引修改 -> O(1)
* 遍历数组 -> O(n)
* 插入数值到数组 -> O(n)
* 从数组删除数值 -> O(n)
* 从数组最后插入/删除 -> O(1)
* js sort排序 -> O(nlogn)

题目：414，88，380，41，59，859

## 栈
后进先出

常见操作
* 进栈 - push -> O(1)
* 出栈 - pop -> O(1)
* 取栈顶 - top -> O(1)
* 判断是否为空栈 - isEmpty -> O(1)

应用
* 深度优先遍历的基础
* 函数调用栈
* 浏览器前进后退
* 匹配括号
* 单调栈寻找下一个更大（小）元素

小知识 -> 波兰表示法(前缀)和逆波兰表示法(后缀)
* 逻辑、算术和代数表示方法
* 操作符的位置（+ 3 4）-> （3 4 +）-> (3 + 4)
* 逆波兰表达式可用栈计算（遇到数字就将数字压栈，遇到操作符，就将栈顶的两个元素取出计算，将计算结果再压入栈）(题目150)

题目：946，150，1381，394，224，227

## 队列
先进先出
 
常见操作
* 插入 - 在队列尾部添加元素
* 删除 - 在队列头部删除元素
* 查看首个元素 - 返回队列头部的元素值

时间复杂度（数组实现）
* 插入 -> O(1) 
* 删除 -> O(n) -> 要实现O(1)可以用两个指针head和tail，需要动态开辟内存
* 查看首个元素 -> O(1)
 
时间复杂度（链表实现）
* 插入 -> O(n) -> 要实现O(1)只要维护一个尾节点引用tail
* 删除 -> O(1)
* 查看首个元素 -> O(1)

应用
* 广度优先遍历（BFS）
* HTTP请求队列

## 数学知识

两点[x1, y1]和[x2, y2]之间的距离 
* d = (x1-x2)² + (y1-y2)², d开根就是两点的距离。
  
排列
* 从n个不同元素中任取m个数，能有多少种排列
* n * (n-1) * ... * (n-m+1)
* 全排列是直接对n个元素进行排列，n * (n-1) * (n-2) * ... * 1

组合
* 从n个不同元素中取出m个数，能有多少种取法（不用考虑排列顺序）
* n(n-1)...(n-m+1) / m(m-1)...1

## 专题

### 前缀和
理解
* 数列nums的前n项和
* pre[i] = pre[i-1] + nums[i]

跟滑动窗口类似，适合在题目要求连续的情况下使用

使用场景
* 差分（1109）
* 前缀和与二分。如果nums是一个正整数数组，那么其前缀和一定单调递增
* 求区间内的 1 的个数。如求任意区间内的1的个数，可以将1以外的数字预处理为0，然后做前缀和，最后做差求区间和（1871）
* 区间值计数。求nums中的值在[lower, upper]之间的数有多少，可以开辟一个与nums值域等大的数组，统计nums值出现的频率，再做前缀和（1862）
* 区间值计数扩展。在上面情况下增加索引限制。可以先做一个二维前缀和pre[i][j]表示前i项j的出现次数（1906）

题目：467，795，904，992，1109

### 栈匹配
使用场景
* 判断有效括号(())
* 链表的回文判断

题目： 20，678，2116

