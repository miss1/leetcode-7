## 搜索

### 状态空间
* 状态空间其实就是一个图结构，图中的节点表示状态，图中的边表示状态之前的联系，这种联系就是题目给出的各种关系。
* 搜索的本质就是在状态空间中进行遍历

### DFS
通过递归函数实现暴力枚举

算法流程
* 1.首先将根节点放入stack中
* 2.从stack中取出第一个节点，判断是否为目标。如果是，结束搜索回传结果，否则将它某一个尚未检验过的子节点直接入栈
* 3.重复步骤2
* 4.如果不存在未检测过的子节点。将上一级节点入栈，重复步骤2
* 5.重复步骤4
* 若stack为空，表示整张图都检查过了

算法模板
```
const visited = {}
function dfs(i) {
 if (满足特定条件）{
  // 返回结果 or 退出搜索空间
 }

 visited[i] = true // 将当前状态标为已搜索
 for (根据i能到达的下个状态j) {
  if (!visited[j]) { // 如果状态j没有被搜索过
   dfs(j)
  }
 }
}
```

二维网格的dfs
* 小岛问题
* 从一个或多个入口DFS即可
* DFS的时候，往四个方向延申

模板
```
let arr = [[1,2,3],[4,5,6],[7,8,9]]
let set = new Set();
function dfs(i, j) {
  if (i < 0 || i >= arr.length || j >= arr[0].length || j < 0) return;
  if (set.has(i + ',' + j)) return;
  // 已访问的添加标记
  console.log(arr[i][j]);
  set.add(i + ',' + j);
  // 下
  dfs(i + 1, j);
  // 上
  dfs(i - 1, j);
  // 右
  dfs(i, j + 1);
  // 左
  dfs(i, j - 1);
}

dfs(0,0);
```

常用技巧
* 前序遍历和后序遍历，注意使用场景
* 迭代加深。通过设定深度阙值，在递归树比较深的时候主动退出
* 双向搜索。有时问题规模过大，直接搜索会超时。可以考虑搜索到问题规模的一半，存储此过程中的状态。接下来目标转化为在存储的中间状态中寻找目标值

### BFS
* 横向搜索方式，从初始状态一层层展开直到目标状态。在数据结构上通常采用队列结构
* 图：每次取出当前节点的所有子节点。二维矩阵（小岛）：每次取当前层的数据向四个方向扩展
* 不断从队头取出状态，然后将此状态对应的决策产生的新状态推入队尾。重复以上过程直至队列为空
* 常常用来求点的最短距离
* eg. 1162

算法流程
* 首先将根节点放入队列
* 从队列取出第一个节点，判断是否为目标。若是，结束搜索回传结果，否则将它所有尚未检验过的直接子节点加入队列
* 若队列为空，表示整张图都检查过

算法模板
```
const visited = {}
function bfs() {
 let q = new Queue()
 q.push(初始状态)
 while(q.length) {
  let i = q.pop()
  if (visited[i]) continue
  for (i的可抵达状态j) {
   if (j 合法) {
    q.push(j)
   }
  }
 }
 // 找到所有合法解
}
```

### 回溯
DFS中的一种技巧，当它通过尝试发现有的分步答案不能得到有效的正确解答时，它将取消上一步甚至上几步的计算，再通过其它的可能的分步答案再次尝试寻找。
通俗的讲，走不通就回头

算法流程
* 构造空间树，即每一步要面临的决策是什么
* 进行遍历（遍历+递归）
* 如果遇到边界条件，不再向下搜索，转而搜索另一条链
* 达到目标条件，输出结果

```
const visited = {}
function dfs(i) {
 if (满足特定条件）{
  // 返回结果 or 退出搜索空间
 }

 visited[i] = true // 将当前状态标为已搜索
 dosomething(i) // 对i做一些操作
 for (根据i能到达的下个状态j) {
  if (!visited[j]) { // 如果状态j没有被搜索过
   dfs(j)
  }
 }
 undo(i) // 恢复i
}
```
题目：36，37，39，40，46，47，52，78，90，113，131

### 减枝
* 回溯的另一个考点，通过恰当的剪枝，可以有效减少时间。
* 原则：避免根本不可能是答案的递归

### 笛卡尔积
* 一些回溯的题目，也可以采用笛卡尔积的方式
* 将结果保存在返回值而不是路径中，避免了回溯状态
* 140，816

### 常用的指标与统计方法

图的DFS序
* dfs过程中访问节点的顺序，包括进入和离开
* 假设一个 x 节点在 dfs 序中出现位置为 l 和 r，那么 dfs 序 D 的子序列[l,r]就是以 x 为根的子序列。

图的拓扑序
* 给一个无环图，如果有一个序列A满足以下条件，那么A就是其拓扑序
* A包含图中所有节点
* 对于图中的每一个边(x,y)，x在A中的位置都在y之前（也可以反过来）

图的联通分量
* 从图中任意一点出发，我们可以访问到的所有的点可以构成一个联通分量

