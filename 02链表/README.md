## 链表

### 结构
```
function ListNode(val, next) {
  this.val = (val===undefined ? 0 : val)
  this.next = (next===undefined ? null : next)
}
```

### 分类
按是否循环
* 循环链表
* 非循环链表

按指针个数
* 单链表，每个节点包括两部分，数据val，next指针
* 双向链表，每个节点包括三部分，数据val，next指针，pre指针（空间换时间）

### 基本操作
插入
* 只需考虑插入位置的前驱节点和后继节点
* 给定指针的情况下，时间复杂度 O(1)
* 如果没有给定指针，需要先遍历找到节点，最坏情况是 O(n)

删除
* 只需将要删除的节点的前驱节点的next指针指向下下个节点
* 删除的时候注意考虑边界条件
* 给定指针的情况下，时间复杂度 O(1)
* 如果没有给定指针，需要先遍历找到节点，最坏情况是 O(n)

遍历
* 循环遍历即可

### 常见题型
反转链表
* 将某个链表进行反转，206
* 将某个链表按K个一组进行反转，25

合并链表
* 将两条有序或无序链表合并成一条有序链表，21
* 将K条有序链表合并成一条有序链表，23

相交或环形链表
* 判断某条链表是否存在环，141
* 获取某条链表环的大小
* 获取环形链表的入环点，142
* 获取两条链表的相交节点，160

设计题
* 要求设计一种数据结构，在指定时间或空间复杂度下完成XX操作

### 常见套路
反转链表
* 记录前一个节点，并使用 当前节点.next = 前一个节点
* time: O(n), space: O(1)

```
let cur = head;
let pre = null;
while (cur) {
  const next = cur.next;
  cur.next = pre;
  pre = cur;
  cur = next;
}
return pre;
```

合并链表
* 用两个读指针指向两个有序链表的头
* 一个写指针用于更新合并后的链表

相交链表
* a,b两个指针分别指向A,B两个链表的头，相同的速度移动
* 当a到达尾部时，重新定位到B的头
* 当b到达尾部时，重新定位到A的头
* a,b相遇的点为相交的起始节点，否则没有交点

环形链表
* 快慢指针方法
* 定义一个fast指针，每次前进两步
* 定义一个slow指针，每次前进一步
* 只要存在环，两个指针就一定会相遇
* 当两个指针第一次相遇时，将fast重新定位到链表头部，改成每次前进一步
* 当两个指针再次相遇时，就是环的入口

求链表倒数第K个节点
* 假设K是一个不大于链表长度的正整数
* 使用两个指针，第一个指针先走K步，接下来第二个指针再走
* 这样当第一个指针到达链表末尾的时候，第二个指针刚好位于第倒数第K个