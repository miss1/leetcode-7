## 数组

常见操作
* 随机访问 -> O(1)
* 根据索引修改 -> O(1)
* 遍历数组 -> O(n)
* 插入数值到数组 -> O(n)
* 从数组删除数值 -> O(n)
* 从数组最后插入/删除 -> O(1)
* js sort排序 -> O(nlogn)

题目：414，88，380，41，59，859

## 栈
后进先出

常见操作
* 进栈 - push -> O(1)
* 出栈 - pop -> O(1)
* 取栈顶 - top -> O(1)
* 判断是否为空栈 - isEmpty -> O(1)

应用
* 深度优先遍历的基础
* 函数调用栈
* 浏览器前进后退
* 匹配括号
* 单调栈寻找下一个更大（小）元素

小知识 -> 波兰表示法(前缀)和逆波兰表示法(后缀)
* 逻辑、算术和代数表示方法
* 操作符的位置（+ 3 4）-> （3 4 +）-> (3 + 4)
* 逆波兰表达式可用栈计算（遇到数字就将数字压栈，遇到操作符，就将栈顶的两个元素取出计算，将计算结果再压入栈）(题目150)

题目：946，150，1381，394，224，227

## 队列
先进先出
 
常见操作
* 插入 - 在队列尾部添加元素
* 删除 - 在队列头部删除元素
* 查看首个元素 - 返回队列头部的元素值

时间复杂度（数组实现）
* 插入 -> O(1) 
* 删除 -> O(n) -> 要实现O(1)可以用两个指针head和tail，需要动态开辟内存
* 查看首个元素 -> O(1)
 
时间复杂度（链表实现）
* 插入 -> O(n) -> 要实现O(1)只要维护一个尾节点引用tail
* 删除 -> O(1)
* 查看首个元素 -> O(1)

应用
* 广度优先遍历（BFS）
* HTTP请求队列

## 字符串
'a'.charCodeAt() = 97

## Z array
对于一个string str = [0...n-1], z的长度跟str相等，z[i]存储以s[i]开头的最长子串的长度，这个子串是str的前缀

eg: str = a   a   b   c   a   a   b   x   a   a   a   z

z value = X   1   0   0   3   1   0   0   2   2   1   0

explain: i = 1时， 以str[1]开头的最长子串是abcaabxaaaz，它与str的共同前缀是 a, 长度为1，z[1] = 1

```
function zarray(str) {
  let n = str.length;
  let z = new Array(n).fill(0);
  z[0] = n;
  let l = 0, r = 0;
  for (let i = 1; i < n; i++) {
    if (i > r) {
      l = i;
      r = i;
      while (r < n && str[r-l] === str[r]) r++;
      z[i] = r - l;
      r--;
    } else {
      let k = i - l;
      if (z[k] < r - i + 1) z[i] = z[k];
      else {
        l = i;
        while (r < n && str[r - l] === str[r]) r++;
        z[i] = r - l;
        r--;
      }
    }
  }
  console.log(z);
}
```


z[0]没有什么意义，z[0]的值为str.length，因为以str[0]开头的最长字串是他自己

## 数学知识

两点[x1, y1]和[x2, y2]之间的距离 
* d = (x1-x2)² + (y1-y2)², d开根就是两点的距离。
  
排列
* 从n个不同元素中任取m个数，能有多少种排列
* n * (n-1) * ... * (n-m+1)
* 全排列是直接对n个元素进行排列，n * (n-1) * (n-2) * ... * 1

组合
* 从n个不同元素中取出m个数，能有多少种取法（不用考虑排列顺序）
* n(n-1)...(n-m+1) / m(m-1)...1

## 专题

### 栈匹配
使用场景
* 判断有效括号(())
* 链表的回文判断

题目： 20，678，2116

